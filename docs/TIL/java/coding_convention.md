---
layout: default
title: Coding Convention
parent: JAVA
grand_parent: TIL
last_modified_date: 2022-12-27
---

# Coding Convention
{: .no_toc }

## TABLE OF CONTENTS
{: .no_toc .text-delta }

1. TOC
{:toc}

---
작성중...
# JAVA Coding Convention
[Google Java Style Guide](https://google.github.io/styleguide/javaguide.html)를 참고하고 작성한 글입니다.

## 1 소개
이 문서는 Java™ 프로그래밍 언어의 소스 코드에 대한 Google 코딩 표준의 완전한 정의 역할을 합니다. Java 소스 파일은 여기의 규칙을 준수하는 경우에만 Google 스타일에 있는 것으로 설명됩니다.

다른 프로그래밍 스타일 가이드와 마찬가지로, 코드의 미적 문제뿐만 아니라 다른 유형의 규칙 또는 코딩 표준도 포함합니다. 그러나 이 문서는 주로 우리가 보편적으로 따르는 엄격한 규칙에 초점을 맞추고 있습니다. 

### 1.1 용어 설명
달리 명시되지 않는 한 이 문서에서:

1. *클래스* 라는 용어는 "일반" 클래스, 열거형 클래스, 인터페이스 또는 주석 유형을 의미하기 위해 포괄적으로 사용됩니다(`@interface`).
2. 클래스의 *멤버* 라는 용어 는 중첩된 클래스, 필드, 메서드 또는 생성자를 의미하는 데 포괄적으로 사용됩니다 . 즉, 이니셜라이저와 주석을 제외한 클래스의 모든 최상위 콘텐츠입니다.
3. *주석*이라는 용어는 항상 구현 주석을 나타냅니다. "documentation comments"이라는 문구를 사용하지 않고 대신 일반적인 용어 "Javadoc"을 사용합니다.

다른 "용어 설명"은 문서 전체에 가끔 나타납니다.

### 1.2 안내사항
이 문서의 예제 코드는 비표준입니다. 즉, 예제는 Google 스타일로 되어 있지만 코드를 표현하는 유일한 방법이 아닙니다. 예제에서 선택한 서식은 강제적인 규칙으로 적용되어서는 안 됩니다.

## 2 소스 파일 기본 사항
### 2.1 파일명
소스 파일 이름은 유일해야하며, 최상위 클래스의 이름(대소문자 구별)과 `.java`확장자로 구성됩니다.

### 2.2 파일 인코딩: UTF-8
소스 파일은 UTF-8 로 인코딩됩니다.

### 2.3 특수 문자
#### 2.3.1 공백 문자
줄 종결자 문자를 제외하고 **ASCII 수평 공백 문자 (0x20)**는 소스 파일에서 나타나는 유일한 공백 문자입니다. 이는 다음을 의미합니다.

1. 문자열 및 문자 리터럴의 다른 모든 공백 문자는 이스케이프됩니다.
2. 탭 문자는 들여쓰기에 사용 되지 않습니다.

#### 2.3.2 특수 이스케이프 문자
특수 이스케이프 문자(`\b`, `\t`, `\n`, `\f`, `\r`, `\"`, `\'` 및 `\\`)가 있는 문자의 경우 해당하는 8진수(예:`\012`) 또는 유니코드(예:`\u00a`) 이스케이프 대신 해당 문자가 ​​사용됩니다.

#### 2.3.3 ASCII가 아닌 문자
나머지 비ASCII 문자의 경우 실제 유니코드 문자(예:`∞`) 또는 동등한 유니코드 이스케이프(예:`\u221e`)가 사용됩니다. 문자열 리터럴 및 주석 외부에서의 이스케이프하는 것은 권장되지 않지만 코드를 더 쉽게 읽고 이해하기 쉽게 만들 수 있다면 사용할 수도 있습니다.

* 팁: 유니코드 이스케이프 사례에서 실제 유니코드 문자가 사용되는 경우에도 설명 주석이 매우 유용할 수 있습니다.

* 팁: 일부 프로그램이 ASCII가 아닌 문자를 제대로 처리하지 못할 수 있다는 두려움 때문에 코드를 읽기 어렵게 만들지 마십시오. 그런 일이 발생하면 해당 프로그램은 손상 되었으며 수정 해야 합니다.

## 3 소스 파일 구조
소스 파일은 다음 순서로 구성됩니다.

1. 라이선스 또는 저작권 정보(있는 경우)
2. Package 구문
3. Import 구문
4. 정확히 하나의 최상위 클래스
정확히 하나의 빈 줄이 각 섹션을 구분합니다.

### 3.1 라이선스 또는 저작권 정보(있는 경우)
라이센스 또는 저작권 정보가 파일에 있는 경우 여기에 작성합니다.

### 3.2 Package 구문
Package 구문은 줄 바꿈되지 않습니다.  
열 제한(섹션 4.4 참고, 열 제한: 100)은 Package 구문에 적용되지 않습니다.

### 3.3 Import 구문
#### 3.3.1 와일드카드 import 없음
정적이든(static) 아니든 와일드카드 import는 사용되지 않습니다 .

#### 3.3.2 줄 바꿈 없음
Import 구문은 줄 바꿈되지 않습니다. 열 제한(섹션 4.4 참고, 열 제한: 100)은 Import 구문에 적용되지 않습니다.

#### 3.3.3 순서 및 간격
Import 구문은 다음과 같이 작성됩니다.

1. 모든 static import는 한 블럭에 작성합니다.
2. 모든 non-static import는 한 블럭에 작성합니다.

static import과 non-static import가 모두 있는 경우 하나의 빈 줄이 두 블록을 구분합니다. 각 import 구문 사이에는 다른 빈 줄이 없습니다.  

각 블록 내에서의 이름은 ASCII 정렬 순서로 나타납니다.  
(참고: '.'이 ';'보다 먼저 정렬되기 때문에 import *구문*이 ASCII 정렬 순서대로 정렬되는 것과 동일하지 않습니다.)

#### 3.3.4 클래스에는 static import를 하지 않는다.
static 중첩 클래스에는 static import가 사용되지 않습니다. 일반적인 import를 사용합니다.

### 3.4 클래스 선언
#### 3.4.1 정확히 하나의 최상위 클래스 선언
각 소스 파일마다 각자의 최상위 클래스가 존재합니다.

#### 3.4.2 클래스 내용의 순서
클래스의 멤버 및 이니셜라이저를 선택한 순서는 코드 이해에 큰 영향을 미칠 수 있습니다. 그러나 이에 대한 정확한 규칙은 없습니다. 각각 클래스는 각각 방식으로 순서를 정할 수 있습니다.  

중요한 것은 각 클래스가 *논리적 순서*를 사용 한다는 것 입니다. 요청 시 관리자가 설명할 수 있어야 합니다. 예를 들어, 새로운 메서드는 꼭 클래스의 끝에 추가되는 것이 아닙니다. 그렇게 한다면 논리적 순서가 아닌 "메서드가 추가된 날짜" 순서로 생성되기 때문입니다.

##### 3.4.2.1 Overloads(오버로드): 분할하지 않음
한 클래스에서 동일한 이름을 공유하는 메서드는 중간에 다른 메서드가 끼지 않는 단일 그룹에 나타납니다. 이는 여러 생성자(항상 동일한 이름을 가짐)에도 동일하게 적용됩니다. 이 규칙은 메서드 간에 static 또는 private 등의 수정자가 다른 경우에도 적용됩니다.

## 4 Formatting
용어 참고: 블록과 같은 구조(block-like construct)는 클래스, 메서드 또는 생성자의 본문을 나타냅니다. 배열 이니셜라이저에 대한 섹션 4.8.3.1에 따라 배열 이니셜 라이저는 선택적으로 블록과 같은 구조인 것처럼 처리될 수 있습니다.

### 4.1 중괄호
#### 4.1.1 선택적 중괄호 사용
중괄호는 본문이 비어 있거나 한문장만 포함하는 경우에도, `if`, `else`, `for`, `do` and `while`문과 함께 사용됩니다.  

람다식과 같이 중괄호를 선택적으로 사용할 수 있는 경우 중괄호는 선택 사항으로 유지됩니다.

#### 4.1.2 비어 있지 않은 블록: K & R 스타일
중괄호는 *비어 있지 않은 블록* 및 *블록과 같은 구조* 에 대해 Kernighan and Ritchie 스타일("이집트 대괄호")을 따릅니다.

* 아래에 설명된 경우를 제외하고 여는 중괄호 앞에 줄 바꿈이 없습니다.
* 여는 중괄호 뒤에 줄 바꿈.
* 닫는 중괄호 앞의 줄 바꿈.
* 닫는 중괄호 뒤의 줄 바꿈은 해당 중괄호가 명령문을 종료하거나 메서드, 생성자 또는 명명된 클래스의 본문을 종료하는 경우에만 해당됩니다. 예를 들어 중괄호 뒤에 `else` 또는 쉼표가 있으면 줄 바꿈이 없습니다.

예외: 세미콜론(`;`)으로 끝나는 단일 명령문을 허용하는 곳에서는 코드 블록이 나타날 수 있으며 이 블록의 여는 중괄호 앞에 줄 바꿈이 있습니다. 이와 같은 블록은 일반적으로 지역 변수의 범위를 제한하기 위해 도입됩니다(예: switch 문 내부).      
  
enum 클래스에 대한 몇 가지 예외는 섹션 4.8.1, Enum 클래스에 나와 있습니다.

#### 4.1.3 빈 블록: 간결할 수 있습니다.
빈 블록 또는 블록과 같은 구조는 K & R 스타일일 수 있습니다(섹션 4.1.2 참조). 혹은 다중 블록 코드(다중 블록을 직접 포함하는 명령문: `if/else` 또는 `try/catch/finally`)의 일부가 아니라면 아무 문자나 줄 바꿈 없이 열린 후 즉시 닫힐 수 있습니다(`{}`).   
     
### 4.2 들여쓰기: +2 칸
새 블록이나 블록과 같은 구조가 열릴 때마다 들여쓰기가 두 칸씩 증가합니다. 블록이 끝나면 들여쓰기가 이전 들여쓰기 수준으로 돌아갑니다. 들여쓰기 수준은 블록 전체의 코드와 주석 모두에 적용됩니다. (섹션 4.1.2, 비어 있지 않은 블록: K & R 스타일의 예를 참조하십시오.)

### 4.3 한 줄에 하나의 문장
각 줄 다음에는 줄 바꿈이 옵니다.

### 4.4 열 제한: 100
Java 코드의 열 제한은 100자입니다. "문자"는 모든 유니코드 코드 포인트를 의미합니다. 아래에 명시된 경우를 제외하고 이 제한을 초과하는 줄은 4.5절 줄 바꿈에서 설명한 대로 줄 바꿈해야 합니다.

참고: 각 유니코드 코드 포인트는 표시 너비가 더 크거나 작더라도 하나의 문자로 계산됩니다. 예를 들어 전각 문자를 사용 하는 경우 이 규칙이 요구하는 위치보다 먼저 줄 바꿈을 선택할 수 있습니다.

예외:

1. 열 제한을 준수할 수 없는 행(예: Javadoc의 긴 URL 또는 긴 JSNI 메소드 참조문).
2. package및 import문(섹션 3.2 Package 구문 및 3.3 Import 구문 참조).
3. 셸에 복사하여 붙여넣을 수 있는 주석의 명령줄.
4. 매우 긴 식별자는 드물게 호출되지만 열 제한을 초과할 수 있습니다. 이 경우 주변 코드에 대한 유효한 래핑은 [google-java-format](https://github.com/google/google-java-format)에 의해 생성됩니다.

### 4.5 줄 바꿈
용어 참고: 한 줄을 차지할 수 있는 코드를 여러 줄로 나누는 활동을 *줄 바꿈*이라고 합니다.

어느 상황에서든 줄바꿈하는 방법을 정확하게 보여주는 포괄적이고 결정론적인 공식은 없습니다.  
동일한 코드 조각을 줄 바꿈하는 여러 가지 방법이 있는 경우가 많습니다.

참고: 줄 바꿈을 하는 일반적인 이유는 열 제한을 초과하는 것을 방지하기 위한 것이지만 실제로는 열 제한에 맞는 코드라도 작성자의 재량에 따라 줄 바꿈 할 수 있습니다.

팁: 메서드 또는 지역 변수를 추출하면 줄 바꿈 없이도 문제를 해결할 수 있습니다.

#### 4.5.1 줄 바꿈을 할 위치
줄 바꿈의 주요 주요 지침은 더 높은 문법 수준 에서 중단하는 것 입니다.  
또한:
1. 비할당 연산자에서 줄이 끊어지면 기호 앞에 줄 바꿈이 옵니다.
   * 이는 다음과 같은 "연산자와 비슷한" 기호에도 적용됩니다.
     * 점 구분 기호(`.`)
     * 메서드 참조의 두 콜론(`::`)
     * Type 바인딩의 앰퍼샌드(`<T extends Foo & Bar>`)
     * catch 블록 내의 파이프(`catch (FooException | BarException e)`)
2. 대입 연산자 에서 줄이 끊기면 일반적으로 기호 뒤에 줄 바꿈이 오지만 기호 앞에 줄 바꿈이 오는 것도 허용됩니다.
   * 이는 향상된 `for`문("foreach")의 "할당 연산자와 같은" 콜론에도 적용됩니다.
3. 메서드 또는 생성자 이름은 뒤에 오는 여는 괄호( )는 줄 바꿈하지 않습니다.
4. 쉼표(`,`)는 앞에 오는 토큰에 연결된 상태로 유지됩니다.
5. 람다식의 본문이 중괄호가 없는 단일 식으로 구성된 경우 화살표 바로 뒤에 줄 바꿈이 올 수 있다는 점을 제외하고는 람다식의 화살표 옆에서 줄이 끊어지지 않습니다.
```java
MyLambda<String, Long, Object> lambda =
    (String label, Long value, Object obj) -> {
        ...
    };

Predicate<String> predicate = str ->
    longExpressionInvolving(str); 
```        
        
참고: 줄 바꿈의 최우선 목표는 적은 줄의 코드를 작성하는 것이 아니라 명확한 코드를 작성하는 것입니다.

#### 4.5.2 최소 +4칸의 연속 줄 들여쓰기
줄바꿈을 할 때 첫 번째 줄 이후의 각 줄(각 연속된 줄)은 원래 줄에서 적어도 +4만큼 들여쓰기 해야됩니다.  

연속 줄이 여러 개 있는 경우 들여쓰기는 원한다면 +4 이상으로 할 수 있습니다. 일반적으로 두 개의 연속 행은 구문적으로 병렬 요소로 시작하는 경우에만 동일한 들여쓰기 수준을 사용합니다.  

수평 정렬에 관한 섹션 4.6.3은 특정 토큰을 이전 행과 정렬하기 위해 가변 수의 공백을 사용하는 관행을 다루는데 이는 권장되지 않습니다.

## 4.6 공백
### 4.6.1 세로 공백
하나의 빈 줄이 항상 나타납니다.

1. 연속적인 멤버 또는 클래스의 이니셜라이저 사이에서: 필드, 생성자, 메서드, 중첩 클래스, 정적 이니셜라이저 및 인스턴스 이니셜라이저.
   * 예외: 연속된 두 필드 사이의 빈 줄(둘 사이에 다른 코드 없음)은 선택 사항입니다. 이러한 빈 줄은 필요에 따라 필드의 논리적 그룹화 를 만드는 데 사용됩니다 .
예외: enum 상수 사이의 빈 줄은 섹션 4.8.1 에서 다룹니다 .
이 문서의 다른 섹션(예: 섹션 3, 소스 파일 구조 및 섹션 3.3, 가져오기 문 )에서 요구하는 대로.
예를 들어 코드를 논리적 하위 섹션으로 구성하기 위한 명령문 사이와 같이 가독성을 향상시키는 위치에 하나의 빈 줄이 나타날 수도 있습니다. 클래스의 첫 번째 멤버나 이니셜라이저 앞이나 클래스의 마지막 멤버나 이니셜라이저 뒤의 빈 줄은 권장되지도 권장되지도 않습니다.

여러 개의 연속된 빈 줄이 허용되지만 필수(또는 권장)는 아닙니다.

4.6.2 수평 공백
언어 또는 기타 스타일 규칙에서 요구하는 위치를 넘어 리터럴, 주석 및 Javadoc과 별도로 단일 ASCII 공백도 다음 위치 에만 나타납니다 .

if, for또는 와 같은 예약어 를 해당 행에서 catch뒤에 오는 여는 괄호( )에서 분리(
예약어(예: else또는 )를 해당 행에서 앞에 catch오는 닫는 중괄호( )에서 분리}
여는 중괄호( {) 앞, 두 가지 예외:
@SomeAnnotation({a, b})(공간이 사용되지 않음)
String[][] x = {{"foo"}};{{( 아래 항목 9에 의해 , 사이에 공백이 필요하지 않음 )
이항 또는 삼항 연산자의 양쪽에 있습니다. 이는 다음과 같은 "연산자 유사" 기호에도 적용됩니다.
연결 유형 바인딩의 앰퍼샌드: <T extends Foo & Bar>
여러 예외를 처리하는 catch 블록용 파이프: catch (FooException | BarException e)
:향상된 for("foreach") 문의 콜론( )
람다 식의 화살표: (String str) -> str.length()
하지만
메서드 참조 의 두 콜론( ::)은 다음과 같이 작성됩니다.Object::toString
점 구분 기호( .)는 다음과 같이 작성됩니다. object.toString()
캐스트 뒤 ,:;또는 닫는 괄호( ))
//내용과 주석을 시작하는 이중 슬래시( ) 사이 . 여러 공백이 허용됩니다.
주석을 시작 하는 이중 슬래시( //)와 주석의 텍스트 사이. 여러 공백이 허용됩니다.
선언의 유형과 변수 사이: List<String> list
배열 이니셜라이저의 두 중괄호 안에 있는 선택 사항
new int[] {5, 6}그리고 둘 다 유효하다new int[] { 5, 6 }
유형 주석 및 []또는 사이 ....
이 규칙은 줄의 시작이나 끝에서 추가 공간을 요구하거나 금지하는 것으로 해석되지 않습니다. 그것은 내부 공간 만을 다룬다 .

4.6.3 수평 정렬: 필요하지 않음
용어 참고 사항: 가로 정렬 은 특정 토큰이 이전 줄의 다른 특정 토큰 바로 아래에 나타나도록 하기 위해 코드에 가변 개수의 추가 공백을 추가하는 방법입니다.

이 관행은 허용되지만 Google Style 에서는 절대 요구하지 않습니다 . 이미 사용된 곳에서 수평 정렬 을 유지할 필요조차 없습니다 .

다음은 정렬을 사용하지 않고 정렬을 사용하는 예입니다.

개인 int x ; // 이것은 훌륭한 private Color 입니다 color ; // 이것도 비공개 int    x ; // 허용되지만 향후 편집 private Color color ; // 정렬되지 않은 상태로 둘 수 있음  
  

       
   
팁: 정렬은 가독성을 높일 수 있지만 향후 유지 관리에 문제를 일으킵니다. 한 줄만 터치해야 하는 미래의 변화를 고려하십시오. 이 변경으로 인해 이전에는 만족스러웠던 형식이 망가진 상태로 남을 수 있으며 이는 허용 됩니다. 더 자주 코더(아마도 당신)가 인근 줄의 공백을 조정하도록 프롬프트를 표시하여 계단식 일련의 재포맷을 트리거할 수 있습니다. 그 한 줄 변경에는 이제 "폭발 반경"이 있습니다. 이것은 최악의 경우 무의미한 바쁜 작업을 초래할 수 있지만 기껏해야 버전 기록 정보를 손상시키고 검토자의 속도를 늦추며 병합 충돌을 악화시킵니다.

4.7 괄호 그룹화: 권장
선택적 그룹화 괄호는 저자와 검토자가 괄호가 없으면 코드가 잘못 해석될 가능성이 없으며 코드를 더 쉽게 읽을 수 없다는 데 동의하는 경우에만 생략됩니다. 모든 독자가 전체 Java 연산자 우선 순위 테이블을 기억하고 있다고 가정하는 것은 합리적 이지 않습니다 .

4.8 특정 구조
4.8.1 열거형 클래스
enum 상수 뒤에 오는 각 쉼표 뒤에는 줄 바꿈이 선택 사항입니다. 추가 빈 줄(보통 한 줄)도 허용됩니다. 이것은 한 가지 가능성입니다.

private enum Answer { 
  YES { @Override public String toString () { return "yes" ; } }, 
  아니오 , 
  어쩌면 }   
       
       
    
  

메서드가 없고 상수에 대한 문서가 없는 enum 클래스는 선택적으로 배열 이니셜라이저인 것처럼 형식을 지정할 수 있습니다(배열 이니셜라이저에 대한 섹션 4.8.3.1 참조 ) .

개인 enum 수트 { 클럽 , 하트 , 스페이드 , 다이아몬드 }   
열거형 클래스 는 클래스 이므로 클래스 형식화에 대한 다른 모든 규칙이 적용됩니다.

4.8.2 변수 선언
4.8.2.1 선언당 하나의 변수
모든 변수 선언(필드 또는 로컬)은 하나의 변수만 선언합니다. 와 같은 선언 int a, b;은 사용되지 않습니다.

예외:for 루프 의 헤더에서 여러 변수 선언이 허용됩니다 .

4.8.2.2 필요할 때 선언
지역 변수는 컨테이닝 블록이나 블록과 같은 구성의 시작 부분에서 습관적으로 선언 되지 않습니다 . 대신 지역 변수는 범위를 최소화하기 위해 (합리적인 범위 내에서) 처음 사용된 지점에 가깝게 선언됩니다. 지역 변수 선언에는 일반적으로 이니셜라이저가 있거나 선언 직후에 초기화됩니다.

4.8.3 어레이
4.8.3.1 배열 이니셜라이저: "블록과 유사"할 수 있습니다.
배열 이니셜라이저는 선택적 으로 "블록과 같은 구성"인 것처럼 형식을 지정할 수 있습니다. 예를 들어, 다음은 모두 유효합니다( 전체 목록이 아님) .

새로운 정수 [] { 새로운 정수 [] { 0 , 1 , 2 , 3 0 , } 1 , 2 , 새로운 정수 [] { 3 , 0 , 1 , } 2 , 3 } 새로운 정수 [] { 0 , 1 , 2 , 3 }               
                 
                       
                        
               
                  
   
                      
                             
4.8.3.2 C 스타일 배열 선언 없음
대괄호 는 변수가 아닌 유형 의 일부를 형성합니다: , not .String[] argsString args[]

4.8.4 스위치 문
용어 참고: 스위치 블록 의 중괄호 안에는 하나 이상의 명령문 그룹 이 있습니다. 각 명령문 그룹은 하나 이상의 스위치 레이블 ( 또는 )과 하나 이상의 명령문(또는 마지막 명령문 그룹의 경우 0 개 이상의 명령문)으로 구성됩니다.case FOO:default:

4.8.4.1 들여쓰기
다른 블록과 마찬가지로 스위치 블록의 내용은 +2 들여쓰기됩니다.

스위치 레이블 다음에 줄바꿈이 있고 마치 블록이 열리는 것처럼 들여쓰기 수준이 +2 증가합니다. 다음 스위치 레이블은 마치 블록이 닫힌 것처럼 이전 들여쓰기 수준으로 돌아갑니다.

4.8.4.2 통과: 주석 처리됨
스위치 블록 내에서 각 문 그룹은 갑자기 종료되거나( , break또는 throw된 예외와 함께) 실행이 다음 문 그룹으로 계속되거나 계속될 수 있음을 나타내는 주석으로 표시됩니다. 대체 아이디어를 전달하는 모든 주석이면 충분합니다(일반적으로 ). 이 특수 주석은 스위치 블록의 마지막 명령문 그룹에 필요하지 않습니다. 예시:continuereturn// fall through

switch ( 입력 ) { 경우 1 : 경우 2 : 
    prepareOneOrTwo (); // 케이스 3 통과 : 
    handleOneTwoOrThree (); 휴식 ; 기본값 : 
    handleLargeNumber ( 입력 ); }  
   
   
    
   
    
  
문 그룹의 끝에만 뒤에는 주석이 필요하지 않습니다 .case 1:

4.8.4.3 default라벨 의 존재
각 switch 문에는 default코드가 포함되어 있지 않더라도 문 그룹이 포함됩니다.

예외: 유형 에 대한 switch 문은 해당 enum유형 의 가능한 모든 값을 포함하는 명시적 사례를 포함하는 경우 문 그룹을 생략 할 수 있습니다 . 이를 통해 IDE 또는 기타 정적 분석 도구는 사례가 누락된 경우 경고를 발행할 수 있습니다. default

4.8.5 주석
4.8.5.1 유형 사용 주석
유형 사용 주석은 주석이 달린 유형 바로 앞에 나타납니다. 로 메타 주석이 달린 주석은 유형 사용 주석입니다 . 예시:@Target(ElementType.TYPE_USE)

최종 @Nullable 문자열 이름 ; public @Nullable Person getPersonByName ( 문자열 이름 );  

  
4.8.5.2 클래스 주석
클래스에 적용되는 주석은 문서 ​​블록 바로 뒤에 나타나며 각 주석은 자체 행에 나열됩니다(즉, 행당 하나의 주석). 이러한 줄 바꿈은 줄 바꿈(4.5절, 줄 바꿈 )을 구성하지 않으므로 들여쓰기 수준이 증가하지 않습니다. 예시:

@Deprecated @CheckReturnValue 공개 최종 클래스 Frozzler { ... }

      
4.8.5.3 메서드 및 생성자 주석
메서드 및 생성자 선언에 대한 주석 규칙은 이전 섹션 과 동일합니다 . 예시:

@Deprecated @Override 공개 문자열 getNameIfPresent () { ... }

    
예외: 단일 매개변수 없는 주석 이 대신 서명의 첫 번째 줄과 함께 나타날 수 있습니다. 예를 들면 다음과 같습니다.

@Override public int hashCode () { ... }     
4.8.5.4 필드 주석
필드에 적용되는 주석도 문서 블록 바로 뒤에 나타나지만 이 경우 여러 주석(매개변수화 가능)이 같은 줄에 나열될 수 있습니다. 예를 들어:

@Partial @Mock DataLoader 로더 ;  
4.8.5.5 매개변수 및 로컬 변수 주석
매개 변수 또는 지역 변수에 대한 주석 형식 지정에 대한 특정 규칙은 없습니다(물론 주석이 유형 사용 주석인 경우 제외).

4.8.6 설명
이 섹션에서는 구현에 대한 설명을 다룹니다 . Javadoc은 섹션 7, Javadoc 에서 별도로 다룹니다 .

모든 줄 바꿈 앞에는 임의의 공백과 구현 주석이 올 수 있습니다. 이러한 주석은 행을 공백이 아닌 것으로 렌더링합니다.

4.8.6.1 블록 주석 스타일
블록 주석은 주변 코드와 동일한 수준으로 들여쓰기됩니다. 그들은 /* ... */스타일이나 // ...스타일 일 수 있습니다. 여러 줄 /* ... */주석의 경우 후속 줄은 이전 줄에 *정렬된 상태로 시작해야 합니다.*

/* 
 * 이것은 // 그래서 /* 또는 당신은 할 수 있습니다 
 * 오케이. // 이거다. * 이렇게라도 하세요. */ */
 
주석은 별표 또는 기타 문자로 그려진 상자로 둘러싸이지 않습니다.

팁: 여러 줄 주석을 작성할 때 /* ... */자동 코드 포맷터가 필요할 때 줄을 다시 줄 바꿈하도록 하려면 스타일을 사용하십시오(단락 스타일). // ...대부분의 포맷터는 스타일 주석 블록 에서 줄을 다시 줄 바꿈하지 않습니다 .

4.8.7 수정자
클래스 및 멤버 한정자가 있는 경우 Java 언어 사양에서 권장하는 순서대로 나타납니다.

공개 보호 개인 추상 기본 정적 최종 임시 휘발성 동기화 기본 strictfp
4.8.8 숫자 리터럴
long- 값이 있는 정수 리터럴은 대문자 L접미사를 사용하며 소문자는 절대 사용하지 않습니다(숫자와 혼동을 피하기 위해 1). 예를 3000000000L 들어 3000000000l.

5 명명
5.1 모든 식별자에 공통되는 규칙
식별자는 ASCII 문자와 숫자만 사용하며 아래에 언급된 소수의 경우 밑줄을 사용합니다. 따라서 각각의 유효한 식별자 이름은 정규식과 일치합니다 \w+.

Google Style에서는 특별한 접두사 또는 접미사를 사용 하지 않습니다 . 예를 들어 다음 이름은 Google 스타일이 아닙니다 : name_, mName및 .s_namekName

5.2 식별자 유형별 규칙
5.2.1 패키지 이름
패키지 이름은 소문자와 숫자만 사용합니다(밑줄 없음). 연속된 단어는 단순히 함께 연결됩니다. 예를 들어, com.example.deepspace, 아님 com.example.deepSpace또는 com.example.deep_space.

5.2.2 클래스 이름
클래스 이름은 UpperCamelCase 로 작성됩니다 .

클래스 이름은 일반적으로 명사 또는 명사구입니다. 예를 들어, Character또는 ImmutableList. 인터페이스 이름은 명사 또는 명사구(예: List)일 수도 있지만 경우에 따라 형용사 또는 형용사구일 수도 있습니다(예: Readable).

주석 유형의 이름을 지정하기 위한 특정 규칙이나 잘 확립된 규칙이 없습니다.

테스트 클래스 에는 로 끝나는 이름이 있습니다 Test(예: ) HashIntegrationTest. 단일 클래스를 포함하는 경우 해당 이름은 해당 클래스의 이름에 를 더한 것 Test입니다(예: ) HashImplTest.

5.2.3 메소드 이름
메서드 이름은 lowerCamelCase 로 작성됩니다 .

메서드 이름은 일반적으로 동사 또는 동사구입니다. 예를 들어, sendMessage또는 stop.

밑줄은 이름의 논리적 구성 요소를 구분하기 위해 JUnit 테스트 메서드 이름에 나타날 수 있습니다 . 예를 들어 각 구성 요소는 lowerCamelCase 로 작성됩니다 transferMoney_deductsFromSource. 테스트 방법의 이름을 지정하는 올바른 방법은 없습니다.

5.2.4 상수 이름
상수 이름 사용 UPPER_SNAKE_CASE: 모든 대문자, 각 단어는 단일 밑줄로 다음 단어와 구분됩니다. 그러나 상수란 정확히 무엇입니까 ?

상수는 내용이 완전히 변경 불가능하고 메서드에 부작용이 감지되지 않는 정적 최종 필드입니다. 예를 들면 프리미티브, 문자열, 불변 값 클래스 및 null. 인스턴스의 관찰 가능한 상태가 변경될 수 있는 경우 이는 상수가 아닙니다. 개체를 절대 변경하지 않으려는 의도만으로는 충분하지 않습니다 . 예:

// 상수 static final int NUMBER = 5 ; 정적 최종 ImmutableList < String > NAMES = ImmutableList . of ( "Ed" , "Ann" ); 정적 최종 맵 < String , Integer > AGES = ImmutableMap . of ( "Ed" , 35 , "Ann" , 32 ); 정적 최종 조이너 COMMA_JOINER
   
    
       
  = 결합자 . 에 ( ',' ); // Joiner는 불변이기 때문에 static final SomeMutableType [] EMPTY_ARRAY = {}; // 상수가 아님 static String nonFinal = "non-final" ; final String nonStatic = "비정적" ; static final Set < String > mutableCollection = new HashSet < String >(); 정적 최종 ImmutableSet <  
   


  
  
    
  SomeMutableType > mutableElements = ImmutableSet . ( 가변 ) ; 정적 최종 ImmutableMap < String , SomeMutableType > mutableValues ​​= ImmutableMap . of ( "Ed" , mutableInstance , "Ann" , mutableInstance2 ); 정적 최종 로거 로거 = 로거 . getLogger ( MyClass.getName ( )) ; 공전 
   
     
   
 final String [] nonEmptyArray = { "these" , "can" , "change" };    
이러한 이름은 일반적으로 명사 또는 명사구입니다.

5.2.5 상수가 아닌 필드 이름
상수가 아닌 필드 이름(정적 또는 기타)은 lowerCamelCase 로 작성됩니다 .

이러한 이름은 일반적으로 명사 또는 명사구입니다. 예를 들어, computedValues또는 index.

5.2.6 매개변수 이름
매개변수 이름은 lowerCamelCase 로 작성됩니다 .

공용 메소드에서 한 문자 매개변수 이름은 피해야 합니다.

5.2.7 지역 변수 이름
지역 변수 이름은 lowerCamelCase 로 작성됩니다 .

최종적이고 변경할 수 없는 경우에도 지역 변수는 상수로 간주되지 않으며 상수로 스타일을 지정하면 안 됩니다.

5.2.8 유형 변수 이름
각 유형 변수는 다음 두 가지 스타일 중 하나로 명명됩니다.

단일 대문자, 선택적으로 단일 숫자(예: E, T, X, T2)
클래스에 사용되는 형식의 이름(섹션 5.2.2, 클래스 이름 참조) 뒤에 대문자가 옵니다 T(예: RequestT, FooBarT).
5.3 카멜 케이스: 정의됨
"IPv6" 또는 "iOS"와 같은 두문자어 또는 특이한 구문이 있는 경우와 같이 영어 구를 카멜 표기법으로 변환하는 합리적인 방법이 두 가지 이상인 경우가 있습니다. 예측 가능성을 개선하기 위해 Google Style은 다음과 같은 (거의) 결정적 체계를 지정합니다.

이름의 산문 형식으로 시작:

문구를 일반 ASCII로 변환하고 아포스트로피를 제거하십시오. 예를 들어 "Müller's algorithm"은 "Muellers algorithm"이 될 수 있습니다.
이 결과를 단어로 나누고 공백과 나머지 구두점(일반적으로 하이픈)으로 나눕니다.
권장 사항: 어떤 단어가 이미 일반적으로 사용되는 관습적인 카멜 케이스 모양을 가지고 있는 경우 이를 구성 요소로 분할합니다(예: "AdWords"는 "ad words"가 됨). "iOS"와 같은 단어 는 그 자체 로 카멜 케이스가 아닙니다 . 모든 규칙을 따르지 않으므로 이 권장 사항은 적용되지 않습니다.
이제 모든 것을 소문자 로(약어 포함) 다음의 첫 문자만 대문자로:
... 각 단어를 대문자 낙타 케이스 로 만들거나
... 첫 번째 단어를 제외한 각 단어는 소문자 카멜 표기법 을 사용합니다.
마지막으로 모든 단어를 단일 식별자로 결합합니다.
원래 단어의 대소문자는 거의 완전히 무시됩니다. 예:

산문 형식	옳은	잘못된
"XML HTTP 요청"	XmlHttpRequest	XMLHTTPRequest
"신규 고객 ID"	newCustomerId	newCustomerID
"내부 스톱워치"	innerStopwatch	innerStopWatch
"iOS에서 IPv6를 지원합니까?"	supportsIpv6OnIos	supportsIPv6OnIOS
"YouTube 가져오기"	YouTubeImporter
YoutubeImporter*	
*허용되지만 권장되지 않습니다.

참고: 일부 단어는 영어에서 모호하게 하이픈으로 연결됩니다. 예를 들어 "비어 있지 않은"과 "비어 있지 않은"은 모두 정확하므로 메서드 이름 checkNonempty과 checkNonEmpty마찬가지로 둘 다 정확합니다.

6 프로그래밍 실습
6.1 @Override: 항상 사용
메서드는 @Override적법할 때마다 주석으로 표시됩니다. 여기에는 슈퍼클래스 메서드를 재정의하는 클래스 메서드, 인터페이스 메서드를 구현하는 클래스 메서드, 슈퍼인터페이스 메서드를 재지정하는 인터페이스 메서드가 포함됩니다.

예외: @Override 부모 메서드가 이면 생략할 수 있습니다 @Deprecated.

6.2 포착된 예외: 무시되지 않음
아래에 언급된 경우를 제외하고 포착된 예외에 대해 아무 조치도 취하지 않는 것은 거의 올바른 일이 아닙니다. (일반적인 응답은 이를 기록하거나 "불가능"하다고 간주되는 경우 로 다시 던지는 것 AssertionError입니다.)

catch 블록에서 어떠한 조치도 취하지 않는 것이 정말 적절할 때 이것이 정당한 이유는 주석에 설명되어 있습니다.

try { int i = 정수 . parseInt ( 응답 ); handleNumericResponse ( i )를 반환 합니다. } catch ( NumberFormatException ok ) { // 숫자가 아닙니다. 괜찮습니다. 계속 진행 하세요. } return handleTextResponse ( response ); 
   
  
   
  

예외: 테스트에서 발견된 예외는 이름이 이거나 로 시작하는 경우expected 주석 없이 무시될 수 있습니다 . 다음은 테스트 중인 코드 가 예상 유형의 예외를 throw 하는지 확인하기 위한 매우 일반적인 관용구 이므로 여기에서는 주석이 필요하지 않습니다.

{ 
  emptyStack 을 시도 하십시오 . 팝 (); 
  실패 (); } 잡기 ( NoSuchElementException 예상 됨 ) { } 
   
6.3 정적 멤버: 클래스를 사용하여 한정
정적 클래스 멤버에 대한 참조를 한정해야 하는 경우 해당 클래스 유형의 참조나 표현식이 아니라 해당 클래스의 이름으로 한정됩니다.

Foo aFoo = ...; 푸 . aStaticMethod (); // 좋은 aFoo . aStaticMethod (); // 나쁜 뭔가ThatYieldsAFoo (). aStaticMethod (); // 매우 나쁘다 
 
 
 
6.4 종료자: 사용되지 않음
를 재정의하는 것은 극히 드뭅니다 .Object.finalize

팁: 하지 마세요. 반드시 해야 한다면 먼저 Effective Java Item 8 , "Avoid finalizers and cleaners"를 매우 주의 깊게 읽고 이해 한 다음 수행하지 마십시오.

7 자바독
7.1 포맷
7.1.1 일반 형식
Javadoc 블록 의 기본 형식은 다음 예에서 볼 수 있습니다.

/** 
 * 여러 줄의 Javadoc 텍스트가 여기에 작성됩니다. 
 * 정상적으로 래핑됩니다... 
 */ public int method ( String p1 ) { ... }
    
... 또는 이 한 줄 예제에서:

/** 특히 짧은 Javadoc입니다. */
기본 형식은 항상 허용됩니다. 한 줄 형식은 전체 Javadoc 블록(주석 마커 포함)이 한 줄에 맞을 때 대체될 수 있습니다. 와 같은 블록 태그가 없는 경우에만 적용됩니다 @return.

7.1.2 단락
하나의 빈 줄, 즉 정렬된 선행 별표( *)만 포함하는 줄은 단락 사이와 블록 태그 그룹(있는 경우) 앞에 나타납니다. 첫 번째를 제외한 각 단락은 <p>첫 번째 단어 바로 앞에 있고 그 뒤에 공백이 없습니다. <ul>또는 와 같은 다른 블록 수준 요소에 대한 HTML 태그 는 앞에 <table>가 오지 않습니다<p> .

7.1.3 블록 태그
사용되는 모든 표준 "블록 태그"는 @param, @return, @throws, 순서로 나타나며 @deprecated이 네 가지 유형은 빈 설명과 함께 나타나지 않습니다. 블록 태그가 한 줄에 맞지 않으면 연속 줄은 의 위치에서 4개(또는 그 이상)만큼 들여쓰기 @됩니다.

7.2 요약 조각
각 Javadoc 블록은 간략한 요약 조각 으로 시작 합니다. 이 조각은 매우 중요합니다. 클래스 및 메서드 인덱스와 같은 특정 컨텍스트에 나타나는 텍스트의 유일한 부분입니다.

이것은 완전한 문장이 아니라 명사구 또는 동사구인 단편입니다. , 또는 로 시작 하지 않으며 와 같은 완전한 명령문을 형성하지도 않습니다 . 그러나 단편은 마치 완전한 문장인 것처럼 대문자로 구두점을 찍습니다.A {@code Foo} is a...This method returns...Save the record.

팁: 일반적인 실수는 간단한 Javadoc을 형식으로 작성하는 것 /** @return the customer ID */입니다. 이는 올바르지 않으며 로 변경해야 합니다 /** Returns the customer ID. */.

7.3 Javadoc이 사용되는 경우
최소한 Javadoc 은 모든 public클래스 및 이러한 클래스의 모든 public구성원 protected에 대해 존재하며 아래에 언급된 몇 가지 예외가 있습니다.

섹션 7.3.4, 비필수 Javadoc 에 설명된 대로 추가 Javadoc 콘텐츠도 존재할 수 있습니다 .

7.3.1 예외: 설명이 필요 없는 멤버
Javadoc은 와 같은 "단순하고 명백한" 멤버에 대해 선택 사항입니다 . "Returns the foo" 외에는 말할 가치가 없는 경우 입니다 .getFoo()

중요: 일반적인 독자가 알아야 할 관련 정보를 생략하는 것을 정당화하기 위해 이 예외를 인용하는 것은 적절하지 않습니다. 예를 들어 이라는 메서드 의 경우 일반적인 독자가 "표준 이름"이라는 용어가 무엇을 의미하는지 모를 수 있는 경우 getCanonicalName해당 문서를 생략하지 마십시오(단지 라는 근거 포함)./** Returns the canonical name. */

7.3.2 예외: 재정의
상위 유형 메소드를 대체하는 메소드에 Javadoc이 항상 있는 것은 아닙니다.

7.3.4 필요하지 않은 Javadoc
다른 클래스와 멤버는 필요에 따라 Javadoc을 갖 습니다.

구현 주석이 클래스 또는 멤버의 전체 목적이나 동작을 정의하는 데 사용될 때마다 해당 주석은 대신 Javadoc으로 작성됩니다( 사용 /**).

필수가 아닌 Javadoc은 섹션 7.1.1, 7.1.2, 7.1.3 및 7.2의 서식 규칙을 따르도록 엄격하게 요구되지는 않지만 물론 권장됩니다.