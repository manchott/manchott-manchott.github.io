---
layout: default
title: Coding Convention
parent: JAVA
grand_parent: TIL
last_modified_date: 2022-12-27
---

# Coding Convention
{: .no_toc }

## TABLE OF CONTENTS
{: .no_toc .text-delta }

1. TOC
{:toc}

---
# JAVA Coding Convention
[Google Java Style Guide](https://google.github.io/styleguide/javaguide.html)를 참고하고 작성한 글입니다.  
또한 자바에 익숙하지 않아서 이미 윗 글을 번역한 [블로그](https://newwisdom.tistory.com/96)를 참고했습니다.  

# 1 소개
이 문서는 Java™ 프로그래밍 언어의 소스 코드에 대한 Google 코딩 표준의 완전한 정의 역할을 합니다. Java 소스 파일은 여기의 규칙을 준수하는 경우에만 Google 스타일에 있는 것으로 설명됩니다.

다른 프로그래밍 스타일 가이드와 마찬가지로, 코드의 미적 문제뿐만 아니라 다른 유형의 규칙 또는 코딩 표준도 포함합니다. 그러나 이 문서는 주로 우리가 보편적으로 따르는 엄격한 규칙에 초점을 맞추고 있습니다. 

## 1.1 용어 설명
달리 명시되지 않는 한 이 문서에서:

1. *클래스* 라는 용어는 "일반" 클래스, 열거형 클래스, 인터페이스 또는 주석 유형을 의미하기 위해 포괄적으로 사용됩니다(`@interface`).
2. 클래스의 *멤버* 라는 용어 는 중첩된 클래스, 필드, 메서드 또는 생성자를 의미하는 데 포괄적으로 사용됩니다 . 즉, 이니셜라이저와 주석을 제외한 클래스의 모든 최상위 콘텐츠입니다.
3. *주석*이라는 용어는 항상 구현 주석을 나타냅니다. "documentation comments"이라는 문구를 사용하지 않고 대신 일반적인 용어 "Javadoc"을 사용합니다.

다른 "용어 설명"은 문서 전체에 가끔 나타납니다.

## 1.2 안내사항
이 문서의 예제 코드는 비표준입니다. 즉, 예제는 Google 스타일로 되어 있지만 코드를 표현하는 유일한 방법이 아닙니다. 예제에서 선택한 서식은 강제적인 규칙으로 적용되어서는 안 됩니다.

# 2 소스 파일 기본 사항
## 2.1 파일명
소스 파일 이름은 유일해야하며, 최상위 클래스의 이름(대소문자 구별)과 `.java`확장자로 구성됩니다.

## 2.2 파일 인코딩: UTF-8
소스 파일은 UTF-8 로 인코딩됩니다.

## 2.3 특수 문자
### 2.3.1 공백 문자
줄 종결자 문자를 제외하고 **ASCII 수평 공백 문자 (0x20)**는 소스 파일에서 나타나는 유일한 공백 문자입니다. 이는 다음을 의미합니다.

1. 문자열 및 문자 리터럴의 다른 모든 공백 문자는 이스케이프됩니다.
2. 탭 문자는 들여쓰기에 사용 되지 않습니다.

### 2.3.2 특수 이스케이프 문자
특수 이스케이프 문자(`\b`, `\t`, `\n`, `\f`, `\r`, `\"`, `\'` 및 `\\`)가 있는 문자의 경우 해당하는 8진수(예:`\012`) 또는 유니코드(예:`\u00a`) 이스케이프 대신 해당 문자가 ​​사용됩니다.

### 2.3.3 ASCII가 아닌 문자
나머지 비ASCII 문자의 경우 실제 유니코드 문자(예:`∞`) 또는 동등한 유니코드 이스케이프(예:`\u221e`)가 사용됩니다. 문자열 리터럴 및 주석 외부에서의 이스케이프하는 것은 권장되지 않지만 코드를 더 쉽게 읽고 이해하기 쉽게 만들 수 있다면 사용할 수도 있습니다.

* 팁: 유니코드 이스케이프 사례에서 실제 유니코드 문자가 사용되는 경우에도 설명 주석이 매우 유용할 수 있습니다.

* 팁: 일부 프로그램이 ASCII가 아닌 문자를 제대로 처리하지 못할 수 있다는 두려움 때문에 코드를 읽기 어렵게 만들지 마십시오. 그런 일이 발생하면 해당 프로그램은 손상 되었으며 수정 해야 합니다.

# 3 소스 파일 구조
소스 파일은 다음 순서로 구성됩니다.

1. 라이선스 또는 저작권 정보(있는 경우)
2. Package 구문
3. Import 구문
4. 정확히 하나의 최상위 클래스
정확히 하나의 빈 줄이 각 섹션을 구분합니다.

## 3.1 라이선스 또는 저작권 정보(있는 경우)
라이센스 또는 저작권 정보가 파일에 있는 경우 여기에 작성합니다.

## 3.2 Package 구문
Package 구문은 줄 바꿈되지 않습니다.  
열 제한(섹션 4.4 참고, 열 제한: 100)은 Package 구문에 적용되지 않습니다.

## 3.3 Import 구문
### 3.3.1 와일드카드 import 없음
정적이든(static) 아니든 와일드카드 import는 사용되지 않습니다 .

## 3.3.2 줄 바꿈 없음
Import 구문은 줄 바꿈되지 않습니다. 열 제한(섹션 4.4 참고, 열 제한: 100)은 Import 구문에 적용되지 않습니다.

### 3.3.3 순서 및 간격
Import 구문은 다음과 같이 작성됩니다.

1. 모든 static import는 한 블럭에 작성합니다.
2. 모든 non-static import는 한 블럭에 작성합니다.

static import과 non-static import가 모두 있는 경우 하나의 빈 줄이 두 블록을 구분합니다. 각 import 구문 사이에는 다른 빈 줄이 없습니다.  

각 블록 내에서의 이름은 ASCII 정렬 순서로 나타납니다.  
(참고: '.'이 ';'보다 먼저 정렬되기 때문에 import *구문*이 ASCII 정렬 순서대로 정렬되는 것과 동일하지 않습니다.)

### 3.3.4 클래스에는 static import를 하지 않는다.
static 중첩 클래스에는 static import가 사용되지 않습니다. 일반적인 import를 사용합니다.

## 3.4 클래스 선언
### 3.4.1 정확히 하나의 최상위 클래스 선언
각 소스 파일마다 각자의 최상위 클래스가 존재합니다.

### 3.4.2 클래스 내용의 순서
클래스의 멤버 및 이니셜라이저를 선택한 순서는 코드 이해에 큰 영향을 미칠 수 있습니다. 그러나 이에 대한 정확한 규칙은 없습니다. 각각 클래스는 각각 방식으로 순서를 정할 수 있습니다.  

중요한 것은 각 클래스가 *논리적 순서*를 사용 한다는 것 입니다. 요청 시 관리자가 설명할 수 있어야 합니다. 예를 들어, 새로운 메서드는 꼭 클래스의 끝에 추가되는 것이 아닙니다. 그렇게 한다면 논리적 순서가 아닌 "메서드가 추가된 날짜" 순서로 생성되기 때문입니다.

#### 3.4.2.1 Overloads(오버로드): 분할하지 않음
한 클래스에서 동일한 이름을 공유하는 메서드는 중간에 다른 메서드가 끼지 않는 단일 그룹에 나타납니다. 이는 여러 생성자(항상 동일한 이름을 가짐)에도 동일하게 적용됩니다. 이 규칙은 메서드 간에 static 또는 private 등의 수정자가 다른 경우에도 적용됩니다.

# 4 Formatting
용어 참고: 블록과 같은 구조(block-like construct)는 클래스, 메서드 또는 생성자의 본문을 나타냅니다. 배열 이니셜라이저에 대한 섹션 4.8.3.1에 따라 배열 이니셜 라이저는 선택적으로 블록과 같은 구조인 것처럼 처리될 수 있습니다.

## 4.1 중괄호
### 4.1.1 선택적 중괄호 사용
중괄호는 본문이 비어 있거나 한문장만 포함하는 경우에도, `if`, `else`, `for`, `do` and `while`문과 함께 사용됩니다.  

람다식과 같이 중괄호를 선택적으로 사용할 수 있는 경우 중괄호는 선택 사항으로 유지됩니다.

### 4.1.2 비어 있지 않은 블록: K & R 스타일
중괄호는 *비어 있지 않은 블록* 및 *블록과 같은 구조* 에 대해 Kernighan and Ritchie 스타일("이집트 대괄호")을 따릅니다.

* 아래에 설명된 경우를 제외하고 여는 중괄호 앞에 줄 바꿈이 없습니다.
* 여는 중괄호 뒤에 줄 바꿈.
* 닫는 중괄호 앞의 줄 바꿈.
* 닫는 중괄호 뒤의 줄 바꿈은 해당 중괄호가 명령문을 종료하거나 메서드, 생성자 또는 명명된 클래스의 본문을 종료하는 경우에만 해당됩니다. 예를 들어 중괄호 뒤에 `else` 또는 쉼표가 있으면 줄 바꿈이 없습니다.

예외: 세미콜론(`;`)으로 끝나는 단일 명령문을 허용하는 곳에서는 코드 블록이 나타날 수 있으며 이 블록의 여는 중괄호 앞에 줄 바꿈이 있습니다. 이와 같은 블록은 일반적으로 지역 변수의 범위를 제한하기 위해 도입됩니다(예: switch 문 내부).      
  
enum 클래스에 대한 몇 가지 예외는 섹션 4.8.1, Enum 클래스에 나와 있습니다.

### 4.1.3 빈 블록: 간결할 수 있습니다.
빈 블록 또는 블록과 같은 구조는 K & R 스타일일 수 있습니다(섹션 4.1.2 참조). 혹은 다중 블록 코드(다중 블록을 직접 포함하는 명령문: `if/else` 또는 `try/catch/finally`)의 일부가 아니라면 아무 문자나 줄 바꿈 없이 열린 후 즉시 닫힐 수 있습니다(`{}`).   
     
## 4.2 들여쓰기: +2 칸
새 블록이나 블록과 같은 구조가 열릴 때마다 들여쓰기가 두 칸씩 증가합니다. 블록이 끝나면 들여쓰기가 이전 들여쓰기 수준으로 돌아갑니다. 들여쓰기 수준은 블록 전체의 코드와 주석 모두에 적용됩니다. (섹션 4.1.2, 비어 있지 않은 블록: K & R 스타일의 예를 참조하십시오.)

## 4.3 한 줄에 하나의 문장
각 줄 다음에는 줄 바꿈이 옵니다.

## 4.4 열 제한: 100
Java 코드의 열 제한은 100자입니다. "문자"는 모든 유니코드 코드 포인트를 의미합니다. 아래에 명시된 경우를 제외하고 이 제한을 초과하는 줄은 4.5절 줄 바꿈에서 설명한 대로 줄 바꿈해야 합니다.

참고: 각 유니코드 코드 포인트는 표시 너비가 더 크거나 작더라도 하나의 문자로 계산됩니다. 예를 들어 전각 문자를 사용 하는 경우 이 규칙이 요구하는 위치보다 먼저 줄 바꿈을 선택할 수 있습니다.

예외:

1. 열 제한을 준수할 수 없는 행(예: Javadoc의 긴 URL 또는 긴 JSNI 메소드 참조문).
2. package및 import문(섹션 3.2 Package 구문 및 3.3 Import 구문 참조).
3. 셸에 복사하여 붙여넣을 수 있는 주석의 명령줄.
4. 매우 긴 식별자는 드물게 호출되지만 열 제한을 초과할 수 있습니다. 이 경우 주변 코드에 대한 유효한 래핑은 [google-java-format](https://github.com/google/google-java-format)에 의해 생성됩니다.

## 4.5 줄 바꿈
용어 참고: 한 줄을 차지할 수 있는 코드를 여러 줄로 나누는 활동을 *줄 바꿈*이라고 합니다.

어느 상황에서든 줄바꿈하는 방법을 정확하게 보여주는 포괄적이고 결정론적인 공식은 없습니다.  
동일한 코드 조각을 줄 바꿈하는 여러 가지 방법이 있는 경우가 많습니다.

참고: 줄 바꿈을 하는 일반적인 이유는 열 제한을 초과하는 것을 방지하기 위한 것이지만 실제로는 열 제한에 맞는 코드라도 작성자의 재량에 따라 줄 바꿈 할 수 있습니다.

팁: 메서드 또는 지역 변수를 추출하면 줄 바꿈 없이도 문제를 해결할 수 있습니다.

### 4.5.1 줄 바꿈을 할 위치
줄 바꿈의 주요 주요 지침은 더 높은 문법 수준 에서 중단하는 것 입니다.  
또한:
1. 비할당 연산자에서 줄이 끊어지면 기호 앞에 줄 바꿈이 옵니다.
   * 이는 다음과 같은 "연산자와 비슷한" 기호에도 적용됩니다.
     * 점 구분 기호(`.`)
     * 메서드 참조의 두 콜론(`::`)
     * Type 바인딩의 앰퍼샌드(`<T extends Foo & Bar>`)
     * catch 블록 내의 파이프(`catch (FooException | BarException e)`)
2. 대입 연산자 에서 줄이 끊기면 일반적으로 기호 뒤에 줄 바꿈이 오지만 기호 앞에 줄 바꿈이 오는 것도 허용됩니다.
   * 이는 향상된 `for`문("foreach")의 "할당 연산자와 같은" 콜론에도 적용됩니다.
3. 메서드 또는 생성자 이름은 뒤에 오는 여는 괄호( )는 줄 바꿈하지 않습니다.
4. 쉼표(`,`)는 앞에 오는 토큰에 연결된 상태로 유지됩니다.
5. 람다식의 본문이 중괄호가 없는 단일 식으로 구성된 경우 화살표 바로 뒤에 줄 바꿈이 올 수 있다는 점을 제외하고는 람다식의 화살표 옆에서 줄이 끊어지지 않습니다.

```java
MyLambda<String, Long, Object> lambda =
    (String label, Long value, Object obj) -> {
        ...
    };

Predicate<String> predicate = str ->
    longExpressionInvolving(str); 
```        
        
참고: 줄 바꿈의 최우선 목표는 적은 줄의 코드를 작성하는 것이 아니라 명확한 코드를 작성하는 것입니다.

### 4.5.2 최소 +4칸의 연속 줄 들여쓰기
줄바꿈을 할 때 첫 번째 줄 이후의 각 줄(각 연속된 줄)은 원래 줄에서 적어도 +4만큼 들여쓰기 해야됩니다.  

연속 줄이 여러 개 있는 경우 들여쓰기는 원한다면 +4 이상으로 할 수 있습니다. 일반적으로 두 개의 연속 행은 구문적으로 병렬 요소로 시작하는 경우에만 동일한 들여쓰기 수준을 사용합니다.  

수평 정렬에 관한 섹션 4.6.3은 특정 토큰을 이전 행과 정렬하기 위해 가변 수의 공백을 사용하는 관행을 다루는데 이는 권장되지 않습니다.

## 4.6 공백
### 4.6.1 세로 공백
하나의 빈 줄이 항상 나타납니다.

1. 연속적인 멤버 또는 클래스의 이니셜라이저 사이에서: 필드, 생성자, 메서드, 중첩 클래스, 정적 이니셜라이저 및 인스턴스 이니셜라이저.
   * 예외: 연속된 두 필드 사이의 빈 줄(둘 사이에 다른 코드가 없을 경우)은 선택 사항입니다. 이러한 빈 줄은 필요에 따라 필드의 논리적 그룹을 만드는 데 사용됩니다.
   * 예외: enum 상수 사이의 빈 줄은 섹션 4.8.1 에서 다룹니다.
2. 이 문서의 다른 섹션(예: 섹션 3, 소스 파일 구조 및 섹션 3.3, Import 구문)에서 요구하는 대로.
가독성을 향상시키는 위치에 하나의 빈 줄이 나타날 수도 있는데, 예를 들어 코드를 논리적 하위 섹션으로 구성하기 위한 구문 사이에 빈 줄을 넣을 수도 있습니다. 클래스의 첫 번째 멤버나 이니셜라이저 앞이나 클래스의 마지막 멤버나 이니셜라이저 뒤의 빈 줄은 권장되지도 비권장되지도 않습니다.  

여러 개의 연속된 빈 줄이 허용되지만 필수(또는 권장)는 아닙니다.

### 4.6.2 수평 공백
언어 또는 기타 스타일 규칙에서 요구하는 경우 외에 리터럴, 주석 및 Javadoc을 제외하고 단일 ASCII 공백(띄어쓰기)은 **다음 위치에만** 나타납니다 .

1. `if`, `for` 또는 `catch`와 같은 예약어와 그 뒤에 오는 여는 괄호(`(`)를 분리
2. `else` 또는 `catch`와 같은 예약어와 해당 행에서 앞에 오는 닫는 중괄호(`}`)를 분리
3. 여는 중괄호(`{`) 앞에서, 두 가지 예외:
   * `@SomeAnnotation({a, b})` (공백이 사용되지 않음)
   * `String[][] x = {{"foo"}};` (아래 항목 9에 의해 중괄호 두 개 사이에 공백이 필요하지 않음)
4. 이항 또는 삼항 연산자의 양쪽. 이는 다음과 같은 "연산자와 유사한" 기호에도 적용됩니다.
   * 인접한 Type 바인딩의 앰퍼샌드: `<T extends Foo & Bar>`
   * 여러 예외를 처리하는 catch 블록의 파이프: `catch (FooException | BarException e)`
   * 향상된 for("foreach")문의 콜론(`:`)
   * 람다 식의 화살표: `(String str) -> str.length()`
  아래의 경우에는 적용되지 않습니다
   * 메서드 참조의 콜론 두 개(`::`)는 다음과 같이 작성됩니다: `Object::toString`
   * 점 구분 기호(`.`)는 다음과 같이 작성됩니다: `object.toString()`
5. 캐스트 뒤의 닫는 괄호(`)`) 또는 `,:;` 
6. 본문과 주석을 시작 하는 이중 슬래시(`//`) 사이. 여러 공백이 허용됩니다.
7. 주석을 시작 하는 이중 슬래시(`//`)와 주석의 텍스트 사이. 여러 공백이 허용됩니다.
8. 선언의 유형과 변수 사이: `List<String> list`
9. *선택 사항* 배열 이니셜라이저의 두 중괄호 안에서
   * `new int[] {5, 6}`, `new int[] { 5, 6 }` 모두 허용됩니다
10. type annotation과 `[]` 또는 `...`

이 규칙은 줄의 시작이나 끝에서 추가 공간을 요구하거나 금지하는 것으로 해석되지 않고 내부 공간만을 다룹니다.

### 4.6.3 수평 정렬: 필요하지 않음
용어 참고 사항: *수평 정렬*은 특정 토큰이 이전 줄의 다른 특정 토큰 바로 아래에 나타나도록 하기 위해 코드에 가변 개수의 추가 공백을 추가하는 방법입니다.

이 관행은 허용되지만 Google Style 에서는 절대 요구하지 않습니다. 이미 사용된 곳에서 수평 정렬을 유지할 필요조차 없습니다.

다음은 정렬을 사용하지 않는 예시와 정렬을 사용하는 예입니다.
```java
private int x; // 가능합니다
private Color color; // 이것 또한 괜찮습니다

private int   x;      // 허용되지만, 미래에 정렬을 사용하지 않는 방향으로 
private Color color;  // 바뀔 수 있습니다
```       
   
팁: 정렬은 가독성을 높일 수 있지만 향후 유지 관리에 문제를 일으킵니다. 코드 한 줄을 수정해야 하는 미래의 상황을 가정해보십시오. 이 변경으로 인해 이전에는 만족스러웠던 형식이 망가진 상태로 남을 수 있으며 망가진 형식은 사실 허용됩니다. 또한 개발자(아마도 당신)가 인근 줄의 공백도 조정하도록 지시하는 경우가 많아 계단식으로 코드를 재수정해야 할 수도 있습니다. 그 한 줄 변경은 이제 "폭발적인 영향"을 일으킨 것입니다. 이것은 최악의 경우 무의미한 작업을 초래할 수 있지만 기껏해야 버전 기록 정보를 손상시키고 검토자의 속도를 늦추며 merge conflict을 악화시킵니다.

## 4.7 괄호 그룹화: 권장
선택적 그룹화 괄호는 저자와 검토자가 괄호가 없어도 코드가 잘못 해석될 가능성이 없으며 이미 코드를 쉽게 읽을 수 있다는 데 동의하는 경우에만 생략됩니다. 모든 독자가 전체 Java 연산자 우선 순위 테이블을 기억하고 있다고 가정하는 것은 합리적이지 않습니다.

## 4.8 특정 구조
### 4.8.1 enum 클래스
enum 상수 뒤에 오는 각 쉼표 뒤에는 줄 바꿈이 선택 사항입니다. 추가 빈 줄(보통 한 줄)도 허용됩니다. 아래는 예시입니다:
```java
private enum Answer {
  YES {
    @Override public String toString() {
      return "yes";
    }
  },

  NO,
  MAYBE
}
```

메서드가 없고 상수에 대한 문서가 없는 enum 클래스는 선택적으로 배열 이니셜라이저인 것처럼 형식을 지정할 수 있습니다(배열 이니셜라이저에 대한 섹션 4.8.3.1 참조).
* `private enum Suit { CLUBS, HEARTS, SPADES, DIAMONDS }`

enum 클래스는 *클래스* 이므로 클래스 형식화에 대한 다른 모든 규칙이 적용됩니다.

### 4.8.2 변수 선언
#### 4.8.2.1 선언당 하나의 변수
모든 변수 선언(필드 또는 로컬)은 하나의 변수만 선언합니다. `int a, b;` 와 같은 선언은 사용되지 않습니다.

예외: for문의 헤더에서는 여러 변수 선언이 허용됩니다.

#### 4.8.2.2 필요할 때 선언
지역 변수는 포함된 블록이나 블록과 같은 구조의 시작 부분에서 선언 되지 않습니다. 대신 지역 변수는 범위를 최소화하기 위해 (합리적인 범위 내에서) 처음 사용될 지점에 가깝게 선언됩니다. 지역 변수 선언에는 일반적으로 이니셜라이저가 있거나 선언 직후에 초기화됩니다.

### 4.8.3 배열
#### 4.8.3.1 배열 이니셜라이저: "블록과 유사"할 수 있습니다.
배열 이니셜라이저는 선택적 으로 "블록과 같은 구성"인 것처럼 형식을 지정할 수 있습니다. 예를 들어, 다음은 모두 유효합니다:
```java
new int[] {           new int[] {
  0, 1, 2, 3            0,
}                       1,
                        2,
new int[] {             3,
  0, 1,               }
  2, 3
}                     new int[]
                          {0, 1, 2, 3}
```
                             
#### 4.8.3.2 C-스타일 배열 선언 금지
대괄호는 변수가 아닌 Type쪽에 붙습니다: `String args[]`가 아니고 `String[] args`로 작성합니다.

### 4.8.4 스위치 문
용어 참고: *스위치 블록*의 중괄호 안에는 하나 이상의 구문 그룹 이 있습니다. 각 구문 그룹은 하나 이상의 스위치 레이블 (`case FOO:` 또는 `default:`)과 하나 이상의 명령문으로 구성됩니다.(마지막 명령문 그룹의 경우 0개 혹은 그 이상의 명령문)

#### 4.8.4.1 들여쓰기
다른 블록과 마찬가지로 스위치 블록의 내용은 +2 들여쓰기 됩니다.  

스위치 레이블 다음에 줄바꿈이 있고 마치 블록이 열리는 것처럼 들여쓰기 수준이 +2 증가합니다. 다음 스위치 레이블은 마치 블록이 닫힌 것처럼 이전 들여쓰기 수준으로 돌아갑니다.

#### 4.8.4.2 Fall-through: 주석 처리됨
스위치 블록 내에서 각 문 그룹은 갑자기 종료되거나(`break`, `continue` 또는 `return` 혹은 예외 발생) 실행이 다음 문 그룹으로 계속되거나 계속될 수 있을 경우 주석으로 처리됩니다. 상황을 전달하는 주석이면 충분합니다(일반적으로 `// fall through`). 이 특수 주석은 스위치 블록의 마지막 명령문 그룹에 필요하지 않습니다. 예시: 
```java
switch (input) {
  case 1:
  case 2:
    prepareOneOrTwo();
    // fall through
  case 3:
    handleOneTwoOrThree();
    break;
  default:
    handleLargeNumber(input);
}
```

#### 4.8.4.3 `default` 라벨 의 존재
각 switch 문에는 코드가 포함되어 있지 않더라도 `default`문 그룹이 포함됩니다.  

예외: enum 타입에 대한 switch 문은 해당 타입의 가능한 모든 값을 포함하는 경우 `default`문 그룹을 생략 할 수 있습니다 . IDE 또는 기타 정적 분석 도구는 누락된 값이 있을 경우 경고를 발행할 수 있습니다.

### 4.8.5 Annotations
#### 4.8.5.1 타입을 나타내는 Annotations
타입을 나타내는 Annotation은 타입 바로 앞에 나타납니다. `@Target(ElementType.TYPE_USE)` 형식으로 작성합니다. 예시:
```java
final @Nullable String name;

public @Nullable Person getPersonByName(String name);
```

4.8.5.2 클래스 Annotations
클래스 Annotation은 문서 ​​블록 바로 뒤에 나타나며 각 주석은 각 행에 나열됩니다(즉, 행당 하나의 주석). 이러한 줄 바꿈은 줄 바꿈(4.5절, 줄 바꿈)에 해당되지 않으므로 들여쓰기 수준이 증가하지 않습니다. 예시:
```java
@Deprecated
@CheckReturnValue
public final class Frozzler { ... }
```

#### 4.8.5.3 메서드 및 생성자 주석
메서드 및 생성자 선언에 대한 Annotation 규칙은 이전 섹션과 동일합니다. 예시:
```java
@Deprecated
@Override
public String getNameIfPresent() { ... }
```
    
예외: 단일 매개변수 없는 Annotation이 signature의 첫 번째 줄에 함께 나타날 수 있습니다. 예시: 
```java
@Override public int hashCode () { ... }
```


#### 4.8.5.4 필드 Annotation
필드에 적용되는 Annotation도 문서 블록 바로 뒤에 나타나지만 이 경우 여러 Annotation(매개변수화 가능)이 같은 줄에 나열될 수 있습니다. 예시:
```java
@Partial @Mock DataLoader loader;
```

#### 4.8.5.5 매개변수 및 로컬 변수 Annotation
매개 변수 또는 지역 변수에 대한 주석 형식 지정에 대한 특정 규칙은 없습니다(물론 Annotation이 타입을 나타내는 Annotation인 경우 제외).

### 4.8.6 주석
이 섹션에서는 구현 주석에 대한 설명을 다룹니다.  

모든 줄 바꿈 앞에는 공백과 구현 주석이 올 수 있습니다. 이러한 주석은 행을 공백이 아닌 것으로 렌더링합니다.

#### 4.8.6.1 블록 주석 스타일
블록 주석은 주변 코드와 동일한 수준으로 들여쓰기됩니다. 그들은 `/* ... */` 스타일이나 `// ...` 스타일 일 수 있습니다. 여러 줄 `/* ... */` 주석의 경우 다음 줄의 `*`은 이전 줄의 `*`과 정렬된 상태로 시작해야 합니다.  
주석은 별표 또는 기타 문자로 그려진 상자로 둘러싸이지 않습니다.  

팁: 여러 줄 주석을 작성할 때 자동 코드 포맷터가 줄을 다시 감싸도록 하려면 `/* ... */` 스타일을 사용하십시오(단락 스타일). 대부분의 포맷터는 `// ...` 스타일로 주석 블록을 감싸지 않습니다.

### 4.8.7 Modifiers (접근 제한자)
클래스 및 멤버 Modifiers는 있는 경우 Java 언어 사양에서 권장하는 순서로 나타납니다:
`public protected private abstract default static final transient volatile synchronized native strictfp`

### 4.8.8 숫자 리터럴
`long` 값이 있는 정수 리터럴은 대문자 `L`접미사를 사용하며, 소문자는 절대 사용하지 않습니다(숫자 1과의 혼동을 피하기 위해). 예를 들어 `3000000000l` 대신 `3000000000L`로 작성합니다.

# 5 이름 짓기
## 5.1 모든 식별자에 공통되는 규칙
식별자는 ASCII 문자와 숫자만 사용하며 `_`을 사용하는 경우도 있습니다. 따라서 각 유효한 식별자 이름은  `\w+` 정규식과 일치합니다.

Google Style에서는 특별한 접두사 또는 접미사를 사용 하지 않습니다. 예를 들어 다음 이름은 Google 스타일이 아닙니다: `name_`, `mName`, `s_name` 및 `kName`

## 5.2 식별자 유형별 규칙
### 5.2.1 패키지 이름
패키지 이름은 소문자와 숫자만 사용합니다(밑줄 없음). 연속된 단어는 연결해서 작성합니다. 예를 들어, `com.example.deepspace`로 작성하지, `com.example.deepSpace` 또는 `com.example.deep_space`으로 작성하지 않습니다.

### 5.2.2 클래스 이름
클래스 이름은 UpperCamelCase로 작성됩니다.  

클래스 이름은 일반적으로 명사 또는 명사구입니다. 예를 들어, `Character` 또는 `ImmutableList`처럼 작성합니다. 인터페이스 이름은 명사 또는 명사구(예: `List`)일 수도 있지만 경우에 따라 형용사 또는 형용사구일 수도 있습니다(예: `Readable`).  

annotation 타입의 이름을 지정하기 위한 특정 규칙이나 확립된 규칙은 없습니다.  

테스트 클래스는 `Test`로 끝나는 이름을 사용해야 합니다(예: `HashIntegrationTest`). 단일 클래스를 포함하는 경우 해당 이름은 해당 클래스의 이름에 `Test`를 더한 것 입니다(예: `HashImplTest`).

### 5.2.3 메서드 이름
메서드 이름은 lowerCamelCase 로 작성됩니다.  

메서드 이름은 일반적으로 동사 또는 동사구입니다. 예를 들어, `sendMessage` 또는 `stop`처럼 작성합니다.  

밑줄은 이름의 논리적 구성 요소를 구분하기 위해 JUnit 테스트 메서드 이름에 나타날 수 있습니다. 각 구성 요소는 lowerCamelCase로 작성됩니다(예: `transferMoney_deductsFromSource`). 테스트 메서드의 이름을 지정하는 방법은 다양합니다.

### 5.2.4 상수 이름
상수 이름 사용 UPPER_SNAKE_CASE로 작성합니다: 모두 대문자로 쓰고, 각 단어는 단일 밑줄로 다음 단어와 구분됩니다. 그러나 상수란 정확히 무엇입니까?

상수는 내용이 불변하고 메서드에 부작용이 감지되지 않는 static final 필드입니다. 예를 들면 primitives, Strings, immutable types, `null`로 설정된 모든 것이 포함됩니다. 인스턴스의 상태가 변경될 수 있는 경우 이는 상수가 아닙니다. 개체를 절대 변경하지 않으려는 *의도만으로는* 충분하지 않습니다. 예:
```java
// Constants
static final int NUMBER = 5;
static final ImmutableList<String> NAMES = ImmutableList.of("Ed", "Ann");
static final Map<String, Integer> AGES = ImmutableMap.of("Ed", 35, "Ann", 32);
static final Joiner COMMA_JOINER = Joiner.on(','); // because Joiner is immutable
static final SomeMutableType[] EMPTY_ARRAY = {};

// Not constants
static String nonFinal = "non-final";
final String nonStatic = "non-static";
static final Set<String> mutableCollection = new HashSet<String>();
static final ImmutableSet<SomeMutableType> mutableElements = ImmutableSet.of(mutable);
static final ImmutableMap<String, SomeMutableType> mutableValues =
    ImmutableMap.of("Ed", mutableInstance, "Ann", mutableInstance2);
static final Logger logger = Logger.getLogger(MyClass.getName());
static final String[] nonEmptyArray = {"these", "can", "change"};
```
  
상수 이름은 일반적으로 명사 또는 명사구입니다.

### 5.2.5 상수가 아닌 필드 이름
상수가 아닌 필드 이름(static 등)은 lowerCamelCase 로 작성됩니다.  

이들은 일반적으로 명사 또는 명사구입니다. 예를 들어, `computedValues`또는 `index`.

### 5.2.6 매개변수 이름
매개변수 이름은 lowerCamelCase로 작성됩니다.  

공용 메소드에서 한 글자의 매개변수 이름은 피해야 합니다.

### 5.2.7 지역 변수 이름
지역 변수 이름은 lowerCamelCase로 작성됩니다.  

final이고 변경할 수 없는 경우에도 지역 변수는 상수로 간주되지 않으며 상수 스타일을 따르면 안됩니다.

### 5.2.8 Type 변수 이름
각 Type 변수는 다음 두 가지 스타일 중 하나로 명명됩니다.

* 단일 대문자, 간혹 단일 숫자가 따라올 수 있습니다. (예 : `E`, `T`, `X`, `T2`)
* 클래스에 사용되는 형식의 이름(섹션 5.2.2, 클래스 이름 참조) 뒤에 대문자 `T`가 옵니다(예: `RequestT`, `FooBarT`).


## 5.3 카멜 케이스: 정의 된 단어들에 대하여
두문자어 또는 "IPv6", "iOS"와 같은 특이한 구문이 있는 경우를 camel case로 변환하는 방법은 여러가지 있을 수 있습니다. 예측 가능성을 개선하기 위해 Google Style은 다음과 같은 체계를 지정합니다.  

본래 이름에서 시작합니다:

1. 구를 일반 ASCII로 변환하고 아포스트로피를 제거하십시오. 예를 들어 "Müller's algorithm"은 "Muellers algorithm"이 될 수 있습니다.
2. 이 결과를 공백과 나머지 구두점(일반적으로 하이픈)을 기준삼아 단어로 나눕니다.
   * 권장 사항: 어떤 단어가 이미 일반적으로 사용되는 관습적인 카멜 케이스 모양을 가지고 있는 경우 이를 구성 요소로 분할합니다(예: "AdWords"는 "ad words"가 됨). "iOS"와 같은 단어는 그 자체로 camel case가 아닙니다. 어떤 규칙도 따르지 않으므로 이 권장 사항은 적용되지 않습니다.
3. 이제 모든 것을 소문자로(약어 포함) 만들고, 다음 경우를 따릅니다:
   * 각 단어의 첫 글자를 대문자로 바꾸어 UpperCamelCase처럼 만들거나
   * 첫 번째 단어를 제외한 모든 단어의 첫 글자를 대문자로 바꾸어 lowerCamelCase처럼 만듭니다.
4. 마지막으로 모든 단어를 단일 식별자로 결합합니다.
원래 단어의 대소문자는 거의 무시됩니다. 예:

|본래 이름|옳은 방법|틀린 방법|
|------|-----|-----|
|"XML HTTP request"|`XmlHttpRequest`|`XMLHTTPRequest`|
|"new customer ID"|`newCustomerId`|`newCustomerID`|
|"inner stopwatch"|`innerStopwatch`|`innerStopWatch`|
|"supports IPv6 on iOS?"|`supportsIpv6OnIos`|`supportsIPv6OnIOS`|
|"YouTube importer"|`YouTubeImporter`||

참고: 일부 단어는 영어에서 모호하게 하이픈으로 연결됩니다. 예를 들어 "nonempty"와 "non-empty"는 모두 정확하므로 메서드 이름 `checkNonempty`와 `checkNonEmpty` 둘 다 정확합니다.

# 6 프로그래밍 실습
## 6.1 `@Override`: 항상 사용
필요하다면 메서드에 `@Override` annotation을 표시합니다. 여기에는 슈퍼클래스 메서드를 오버라이딩하는 클래스 메서드, 인터페이스 메서드를 구현하는 클래스 메서드, 슈퍼인터페이스 메서드를 재정의하는 인터페이스 메서드가 포함됩니다.  

예외: `@Override`의 부모 메서드가 `@Deprecated`이면 생략할 수 있습니다.

## 6.2 Caught exceptions : 무시되지 않음
아래에 언급된 경우를 제외하고 포착된 예외에 대해 아무 조치도 취하지 않는 것은 거의 올바른 일이 아닙니다.(일반적인 응답은 예외를 기록하거나 "불가능"하다고 간주되는 경우 `AssertionError`로 다시 던지는 것 입니다.)  

catch 블록에서 어떠한 조치도 취하지 않는 것이 정말 적절할 경우 이에 대한 정당한 이유는 주석에 설명합니다.
```java
try {
  int i = Integer.parseInt(response);
  return handleNumericResponse(i);
} catch (NumberFormatException ok) {
  // it's not numeric; that's fine, just continue
}
return handleTextResponse(response);
```

예외: 테스트에서, 이름이 `expected`이거나 `expected`로 시작하는 예외의 경우 주석 없이 무시될 수 있습니다. 다음은 테스트 중인 코드가 예상 유형의 예외를 throw 하는지 확인하기 위한 매우 일반적인 관용구 이므로 여기에서는 주석이 필요하지 않습니다.
```java
try {
  emptyStack.pop();
  fail();
} catch (NoSuchElementException expected) {
}
```

## 6.3 Static members: 클래스를 사용하여 정규화
정적 클래스 멤버에 대한 참조가 정규화되어야하는 경우 해당 클래스 type의 참조 또는 식이 아닌 해당 클래스의 이름으로 정규화됩니다.
```java
Foo aFoo = ...;
Foo.aStaticMethod(); // good
aFoo.aStaticMethod(); // bad
somethingThatYieldsAFoo().aStaticMethod(); // very bad
```
 
6.4 Finalizers: 사용되지 않음
`Object.finalize`를 오버라이딩하는 것은 극히 드뭅니다.

팁: 하지 마세요. 반드시 해야 한다면 먼저 Effective Java Item 8, "Avoid finalizers and cleaners"를 매우 주의 깊게 읽고 이해 한 다음 수행하지 마십시오.

# 7 Javadoc
## 7.1 Formatting
### 7.1.1 일반 형식
Javadoc 블록의 기본 형식은 다음 예에서 볼 수 있습니다:
```java
/**
 * Multiple lines of Javadoc text are written here,
 * wrapped normally...
 */
public int method(String p1) { ... }
```    
... 또는 다음의 한 줄 예제에서 볼 수 있습니다:
```java
/** An especially short bit of Javadoc. */
```
기본 형식은 항상 허용됩니다. 한 줄 형식은 전체 Javadoc 블록(주석 표시 포함)이 한 줄에 들어갈 때 사용될 수 있습니다. `@return`와 같은 블록 태그가 없는 경우에만 적용됩니다.

### 7.1.2 단락
하나의 빈 줄, 즉 정렬 된 선행 별표(`*`) 만 포함 된 줄은 단락 사이와 블록 태그 그룹 (있는 경우) 앞에 나타납니다. 첫 번째 단락을 제외한 각 단락은 첫 번째 단어 바로 앞에 `<p>`가 있으며 그 사이에 공백은 없습니다. `<ul>` 또는 `<table>`와 같은 다른 블록 수준 요소에 대한 HTML 태그는 `<p>`가 앞에 오지 않습니다 .

### 7.1.3 블록 태그
사용되는 모든 표준 "블록 태그"는 `@param`, `@return`, `@throws`, `@deprecated` 순서로 나타나며 이 네 가지 유형은 빈 설명으로 표시되지 않습니다. 블록 태그가 한 줄에 작성되지 않으면 이후의 줄은 `@`의 위치에서 4개(또는 그 이상)만큼 들여쓰기 됩니다.

## 7.2 The summary fragment

각 Javadoc 블록은 간략한 **요약 조각**으로 시작 합니다. 이 조각은 매우 중요합니다. 클래스 및 메서드 인덱스와 같은 특정 컨텍스트에 나타나는 텍스트의 유일한 부분입니다.  

이것은 완전한 문장이 아니라 명사구 또는 동사구입니다. 그러나 마치 완전한 문장인 것처럼 대문자로 시작하고 구두점을 찍습니다.
```java
/** @return the customer ID */. // This is incorrect, and should be changed to 
/** Returns the customer ID. */.
```

## 7.3 Javadoc이 사용되는 곳
최소한 Javadoc 은 모든 public 클래스 및 이러한 클래스의 모든 `public` 혹은 `protected` 구성원에 대해 존재하며 아래에 언급된 몇 가지 예외가 있습니다.  

섹션 7.3.4, 필수가 아닌 Javadoc에 설명된 대로 추가 Javadoc 콘텐츠도 존재할 수 있습니다.

### 7.3.1 예외: 설명이 필요 없는 멤버
Javadoc은 "Returns the foo" 외에는 말할거리가 없는 `getFoo()`와 같은 "단순하고 명백한" 멤버에 대해 선택 사항입니다.  

중요: 독자가 알아야 할 관련 정보 생략을 정당화하기 위해 이 예외를 끌어들이는 것은 적절하지 않습니다. 예를 들어 `getCanonicalName`이라는 메서드가 "Returns the canonical name."외에 할 말이 없을 경우 일반적인 독자가 "canonical name"이라는 용어가 무엇을 의미하는지 모를 수도 있기 떄문에 Javadoc을 생략하지 마십시오.

### 7.3.2 예외: 오버라이딩
상위 유형 메소드를 대체하는 메소드에 Javadoc이 항상 있는 것은 아닙니다.  

### 7.3.4 필수가 아닌 Javadoc
다른 클래스와 멤버는 필요에 따라 Javadoc을 갖습니다.  

구현 주석이 클래스 또는 멤버의 목적이나 동작을 정의하는 데 사용될 때마다 해당 주석은 Javadoc으로 대신 작성됩니다(`/**` 사용).  

필수가 아닌 Javadoc은 섹션 7.1.1, 7.1.2, 7.1.3 및 7.2의 서식 규칙을 따르도록 엄격하게 요구되지는 않지만 물론 권장됩니다.